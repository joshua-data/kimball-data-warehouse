# 📌 다차원 모델 설계의 4단계 절차

### ✅ 1단계: **비즈니스 프로세스 선택**

- **정의**: 조직이 수행하는 가장 작은 단위의 활동 (주문, 청구, 등록, 불만 처리 등)
- **특징**
    - 동사로 표현되는 ‘행위’ 중심
    - 운영 시스템에 의해 추적 가능
    - **성과 지표를 생성**하는 중심 활동
    - 일련의 프로세스는 팩트 테이블의 체인처럼 연결될 수 있음
- **주의점**
    - 부서 중심보다는 프로세스 중심으로 분석
    - 전략적 이니셔티브를 프로세스로 **분해해서 분석**

### ✅ 2단계: **팩트 테이블의 Granularity 정의**

- **정의**: 팩트 테이블의 한 행이 의미하는 바를 명확히 정의
- **예시**
    - 한 개 제품 단위의 판매 트랜잭션
    - 항공권 스캔 단위
    - 월간 은행 계좌 단위
- **중요성**
    - 그레인 정의가 **명확하지 않으면 설계 전반이 무너질 수 있음**
    - 비즈니스 용어로 정의할 것 (단순히 디멘션 나열 금지)
- **실수 주의**
    - 그레인 정의 없이 설계 시작 ❌
    - 팀 전원이 **그레인 정의에 대해 합의** 필요
- **발견된 오류 시**: 반드시 2단계로 돌아가서 재정의하고 다시 설계 진행

### ✅ 3단계: **디멘션 파악하기**

**🔍 1. 디멘션 파악의 목적**

- **디멘션은 팩트 테이블의 의미를 해석할 수 있는 ‘맥락(context)’을 제공**함.
- 앞 단계에서 정의한 **팩트 테이블의 그레인(세분화 수준)** 을 기준으로, 관련된 디멘션을 파악해 **팩트 테이블의 각 로우를 설명**할 수 있도록 구성해야 함.

**🧩 2. 소매업 사례의 주요 디멘션**

- 이미 쉽게 확인할 수 있는 디멘션 예시:
    - **제품 (Product)**: 어떤 상품이 판매되었는가
    - **트랜잭션 (Transaction)**: 어떤 거래 내역인가
- POS 시스템 기준으로 확인 가능한 주요 디멘션:
    - **판매 일자 (Date)**
    - **판매 지점 (Store)**
    - **프로모션 정보 (Promotion)**
    - **계산원 (Cashier)**
    - **지불 방식 (Payment method)**

> ✅ 실제 업무에서는 이런 디멘션들이 비즈니스 사용자의 분석 질문에 직접 연결됩니다.
> 
> 
> 예: “어떤 요일에 어떤 프로모션을 통해 어떤 지점에서 어떤 계산원이 어떤 제품을 얼마나 팔았는가?”
> 

**⚙️ 3. 디멘션과 그레인의 관계**

- 잘 정의된 그레인은 관련된 디멘션들을 **명확히 식별**할 수 있도록 해준다.
- 어떤 디멘션은 **단독**으로 존재하지만,
    - 경우에 따라 **여러 디멘션의 조합**으로부터 파생된 디멘션도 있을 수 있다.
    - 예: 특정 ‘지역 + 시간대’ 조합으로 마케팅 타겟을 나누는 경우

**⚠️ 4. 디멘션 추가 시 주의점**

- **디멘션을 추가하는 행위**가 기존에 정의한 **그레인을 깨뜨리지 않는지 반드시 확인**해야 한다.
- 만약 새 디멘션으로 인해 팩트 테이블에 **새로운 로우가 생성**된다면, 이는 원래의 그레인을 **변형하거나 위반한 것**일 수 있다.

### ✅ 4단계 다차원 모델 설계 요약

**1단계: 비즈니스 프로세스 선택**

- 설계의 출발점: 비즈니스 관점에서 ‘가장 중요하고 실현 가능한’ 프로세스 선정
- 사례에서 선택한 프로세스는 → **POS 소매 트랜잭션**
- 이 프로세스를 선택한 이유:
    - 고객이 어떤 제품을 어떤 시점/지점/프로모션에서 구매했는지 추적 가능
    - 가장 가치 있는 원천 데이터이자, 실무적 의사결정(가격·프로모션)에 직결
- 이 데이터로 파악 가능한 정보:
    - 제품별 판매량, 할인 효과, 시간대별 매출 패턴, 지점별 성과 등

**2단계: 그레인 정의**

- **그레인**이란: 팩트 테이블에서 ‘각 행이 무엇을 의미하는가’
- 목표: **가능한 가장 상세한 수준(atomic grain)** 으로 정의
- 소매업 사례의 그레인 정의:
    - **하나의 POS 트랜잭션에서 발생한 개별 상품 항목 수준**
        - 예: 고객 A가 4개 상품을 구매 → 팩트 테이블에 4개의 행이 생성
- 상세 그레인의 장점:
    - 예측 불가능한 다양한 질의 대응 가능 (e.g., 특정 브랜드의 사이즈별 판매)
    - Drill-down 분석 유연성 확보
    - 요약 데이터는 상세 데이터로부터 쉽게 생성 가능
    - 반대로, 요약 데이터만 있을 경우 상세 분석은 불가

**3단계: 디멘션 파악**

- 팩트의 그레인을 바탕으로 디멘션(맥락)을 정의
- 기본 원칙: **팩트 테이블의 한 행을 설명하기 위해 필요한 모든 디멘션을 도출**
- 소매 POS 사례의 주요 디멘션:
    
    
    | 디멘션 | 설명 |
    | --- | --- |
    | 날짜 (Date) | 판매 발생 일자 (주/월/분기 집계 가능) |
    | 지점 (Store) | 구매가 발생한 매장 |
    | 제품 (Product) | SKU 수준의 상품 정보 |
    | 프로모션 (Promotion) | 해당 제품이 할인·광고 대상인지 여부 |
    | 계산원 (Cashier) | 트랜잭션을 처리한 직원 |
    | 지불 수단 (Payment Method) | 현금, 카드 등 |
- 설계 원칙:
    - 디멘션은 팩트의 그레인을 기준으로 결정
    - 디멘션의 조합으로 새로운 디멘션이 만들어지는 경우 팩트에 포함
    - 단, 디멘션 추가로 인해 그레인을 깨뜨리지 않도록 주의

**4단계: 팩트 파악**

- 팩트: 측정 가능한 수치 (보통 비즈니스 성과 지표)
- 팩트는 보통 **정량적, 집계 가능**한 수치
- 팩트는 **모든 디멘션의 조합 단위로 기록되어야 함**
- 소매 POS 사례의 주요 팩트 예시:
    
    
    | 팩트 | 설명 |
    | --- | --- |
    | 판매 수량 (Quantity Sold) | 해당 SKU의 판매 개수 |
    | 판매 금액 (Sales Amount) | 할인 후 가격 기준 총액 |
    | 원가격 (Original Price) | 할인 전 가격 |
    | 할인 금액 (Discount Amount) | 적용된 프로모션 금액 |
    | 수익 (Profit) | 판매금액 - 비용 (구매가, 간접비 포함 시) |
- 팩트 설계 시 고려사항:
    - 단일 팩트 테이블은 다양한 디멘션에 대해 다수의 팩트를 가질 수 있음
    - 측정값이 존재하지 않는 경우라도 트랜잭션의 이벤트 자체를 기록하는 **팩트리스 팩트 테이블** 설계도 가능 (ex. 재고 없음 이벤트)

## 📅 일자 디멘션

### 1. 일자 디멘션의 역할

- **모든 비즈니스 프로세스는 시간 흐름에 따라 발생**하므로, '일자 디멘션(Date Dimension)'은 다차원 모델에 *항상 포함되는 핵심 디멘션*이다.
- 데이터 웨어하우스에서는 종종 **일자를 기준으로 파티셔닝**하기 때문에, 디스크에 가장 먼저 기록되는 차원이기도 하다.
- Kimball 초판에서는 ‘시간 디멘션(Time Dimension)’이라고 했으나, 현재는 *일자 수준의 그레인을 갖는 '일자 디멘션'*이라는 명칭을 사용함.

### 2. 선행 구축 가능한 디멘션

- 일자 디멘션은 **과거와 미래의 일자까지 미리 만들어 둘 수 있음**.
    - 예: 20년치 → 약 7300개의 row로 작은 크기
- 이렇게 만들어진 테이블은 미래 데이터 적재, 예측, 스케줄링 등에 활용됨.

### 3. 일자 디멘션에 포함되는 대표 속성

| 속성 이름 | 설명 |
| --- | --- |
| 일자 키 (예: 20230101) | 기본 키, 숫자형으로 표현된 날짜 |
| 일자 설명 | “2023년 1월 1일”과 같은 자연어 표현 |
| 요일 | “월요일”, “화요일” 등 |
| 월의 일 숫자 | 해당 월 내 날짜 (1~31) |
| 년의 일 숫자 | 1년 기준 며칠째인지 |
| 분기 / 반기 / 회계월 등 | 다양한 롤업 기준 지원 |
| 주말 여부 / 공휴일 여부 | 보고서 필터나 슬라이싱에 유용 |
| 회계 관련 속성 | 회계 기준의 월/분기/연/주차 |
| 오늘 여부, 60일 전 여부 등 | 매일 갱신되는 동적 속성 |

> 📌 포인트: 단순한 날짜 저장이 아니라, 비즈니스의 다양한 시간 개념을 담는 메타데이터 집합임.
> 

### 4. 일자 디멘션을 명시적으로 구성해야 하는 이유

| ❌ DATE 타입만 사용하는 경우 | ✅ 명시적 일자 디멘션 사용 |
| --- | --- |
| SQL 함수 활용에 능숙해야 함 | 초보자도 쉽게 쿼리 가능 |
| 요일, 분기, 회계 기간 등 표현 어려움 | 다양한 비즈니스 속성 사전 제공 |
| DBMS마다 일자 함수 기능 차이 있음 | 통일된 속성과 구조 제공 |
| 공휴일/주말/계절 등 커스텀 어렵다 | 디멘션 테이블에서 속성 관리 가능 |

> 🔎 예시: 주중 공휴일 vs 주말 공휴일 매출 비교 → SQL 함수로는 어려우며, 디멘션 테이블 조인이 필수
> 

### 5. 설명형 플래그 사용

- `Y/N`, `1/0`, `TRUE/FALSE` → 실제 보고서에선 *“공휴일 / 평일”*, *“주말 / 주중”* 등의 **의미 있는 텍스트로 표현해야** 함.
- **보고서 자체로 의미가 드러나는 UX**를 만들기 위해선 디멘션 속성값이 명확해야 한다.
- BI툴마다 DECODE, CASE WHEN 등 쓰지 않고, **원천 테이블에서 텍스트로 제공하는 것이 일관성 측면에서 우수**.

### 6. 현재 시점과 관련된 동적 속성

- 대부분의 일자 속성은 고정되지만, 일부는 매일 갱신이 필요함:
    - `오늘 여부 (is_today)`
    - `60일 이전 여부`
    - `회계월 마지막 여부` 등
- *ETL 또는 스크립트를 통해 매일 갱신*되어야 하며, 실시간성 보고서에 매우 유용함.

> 💡 참고: Kimball은 “오늘”을 보통 “가장 최근 데이터 적재 일자”로 간주한다고 설명함.
> 

### ✅ 실무 적용 팁

1. **날짜 기준 모든 보고서는 일자 디멘션을 조인해서 작성하는 것**이 기본이다.
2. 미리 `20년치` 일자 디멘션을 만들어 놓고, 매일 `오늘 여부`만 업데이트하는 방식 추천.
3. 공휴일, 주말, 계절 등 조직 특유의 일자 속성은 **비즈니스 로직에 맞게 커스터마이징** 가능하다.
4. Metabase나 Redash 같은 BI툴에서도 사용자가 일자 속성을 쉽게 필터링할 수 있어 **사용자 UX를 대폭 개선**할 수 있음.

## 📘 다대일 계층 관계 해소하기 (제품 디멘션)

### ✅ 1. 제품 디멘션의 계층 구조 이해

- **제품 디멘션**은 SKU를 설명하는 다양한 속성들을 포함함.
- 대표적인 계층 구조:
    
    ```
    SKU → 브랜드 → 카테고리 → 부서
    
    ```
    
- 각 수준은 **다대일(M:1) 관계**이며, 디멘션 테이블의 컬럼으로 표현됨.

📊 **예시: 제품 디멘션**

| 제품 | 설명 | 브랜드 | 부카테고리 | 카테고리 | 부서 | 지방함유 |
| --- | --- | --- | --- | --- | --- | --- |
| 1 | 사우어도우 빵 | 베이크드웰 | 신선식품 | 베이커리 | 베이커리 | 저지방 |
| 2 | 통밀 빵 | 플러피 | 포장제품 | 베이커리 | 베이커리 | 일반 |
| ... | ... | ... | ... | ... | ... | ... |

### ✅ 2. 정규화는 필요 없는가?

- SKU 설명: **30만 개** 유일한 값
- 부서: 약 **50개** 값 → 평균적으로 6천 번 반복
- ✔ 디멘션 테이블은 정규화하지 않아도 괜찮음
    
    → 디스크 공간보다 **모델의 단순성과 성능**이 중요
    

📌 *"팩트 테이블 공간에 비하면 디멘션 공간은 미미하다."*

### ✅ 3. 디멘션의 다양한 속성 예시

| 속성 | 설명 |
| --- | --- |
| 제품 키 | 기본 키 |
| SKU 번호 | 원천 시스템의 자연 키 |
| 제품 설명 | SKU의 설명 |
| 브랜드/카테고리/부서 설명 | 계층 정보 |
| 패키지 타입 | 병, 캔, 박스 등 |
| 패키지 크기, 지방 함유량, 무게 등 | 물리적 속성 |
| 보관/적재 형태 | 물류 관련 정보 |

📌 일반적으로 50개 이상의 속성이 포함됨.

→ 이는 다양한 분석 조건, 필터, 레이블로 활용됨.

### ✅ 4. 의미가 포함된 원천 키 (Natural Key, NK)

- 운영 시스템의 제품 키는 보통 **의미 있는 부분 코드**로 구성됨
- 예:
    - 5~9번째 자리 = 제조사 코드
    - 이 값을 분리해서 **제조사명** 등으로 저장하면 분석에 유리

### ✅ 5. 숫자 값의 위치 선정: 디멘션 vs 팩트

| 기준 | 디멘션 | 팩트 |
| --- | --- | --- |
| 잘 변하지 않음 | ✔ | ❌ |
| 필터, 그룹 기준 | ✔ | ❌ |
| 계산(합산 등) | ❌ | ✔ |

🔁 **혼합 사용 가능성**:

- 디멘션의 `표준 판매가` = 현재 기준
- 팩트의 `표준 판매가` = 이벤트 시점 기준

### 🧾 1. **결제 수단은 거래의 일부로 모델링된다**

- 결제 수단 정보는 **별도의 차원 테이블**로 분리하지 않고, **거래 사실(fact) 테이블 안의 Degenerate Dimension** 형태로 포함됩니다.
- 왜냐하면 결제 수단(신용카드, 현금, 상품권 등)은 **구체적인 속성이 별로 없고**, 대부분의 경우 **Transaction ID나 Payment Type 코드**만으로 충분하기 때문입니다.

### 💳 2. **복수 결제 수단(Multiple Payment Types)의 처리 방법**

**상황: 한 거래에서 여러 결제 수단이 사용됨 (예: 현금 + 카드)**

- 이럴 경우 **한 거래당 하나의 레코드**로 표현하는 것이 불가능합니다.
- 해결 방법은 **복수 행(row) 구조로 fact 테이블을 구성하는 것**입니다.

**예시:**

| Transaction ID | Payment Type | Payment Amount |
| --- | --- | --- |
| 1001 | Credit Card | 50,000 |
| 1001 | Cash | 30,000 |
- 동일한 `Transaction ID`에 대해 여러 `Payment Type`과 `Amount`를 가진 **여러 행으로 분리**합니다.
- 이를 통해 각 결제 수단별 분석도 가능하고, 전체 거래 합산도 문제없이 됩니다.

### 🧠 3. **왜 별도의 결제 차원 테이블을 만들지 않는가?**

- 결제 수단은 보통 정보가 단순(‘카드’, ‘현금’, ‘쿠폰’ 등)하여 차원 테이블을 따로 만들 필요가 없습니다.
- 대신 `payment_type` 같은 값은 **Degenerate Dimension 속성**으로 `fact` 테이블 내에 직접 포함됩니다.

### 🔍 4. **분석 시 장점**

- 여러 결제 수단의 사용 비율, 결제 금액별 분포, 트렌드 등을 분석하기가 쉬워집니다.
- `payment_type` 기준으로 `sum(payment_amount)`를 그룹화하면 분석이 가능합니다.

### 🧩 보충 개념: Degenerate Dimension

- 본래 차원 테이블이 따로 필요 없지만, **사건/거래를 식별하는 키 값**으로 사용되는 열.
- 예: `Transaction ID`, `Invoice Number` 등.

## 📌 1. 팩트 없는 팩트 테이블 (Factless Fact Table)

### ❓ 왜 필요한가?

- "판매되지 않은 프로모션 대상 제품은 무엇인가?"와 같은 **일어나지 않은 사건**에 대한 질문에 답하기 위해 필요함.
- 기존 판매 팩트 테이블은 판매된 SKU만 기록 → **판매되지 않은 SKU는 기록되지 않음**.
- 판매 수량이 0인 SKU까지 모두 기록하면 테이블이 너무 커짐.

### 🔍 해결 방법

- **프로모션 범위 팩트 테이블**을 별도로 설계:
    - 매일/지점/제품/프로모션 단위로 로우를 생성
    - 실제 판매와 무관하게, **프로모션 대상 제품은 모두 한 줄씩 생성**

### 📐 테이블 구조 예시

| 테이블 | 주요 키/속성 |
| --- | --- |
| 날짜 디멘션 | 날짜 키(PK), 요일, 월, 분기, 연도 |
| 제품 디멘션 | 제품 키(PK), SKU 번호, 브랜드, 카테고리 |
| 지점 디멘션 | 지점 키(PK), 지점 번호, 지역, 구역 |
| 프로모션 디멘션 | 프로모션 키(PK), 이름, 미디어 타입, 시작일자 |
| 🟨 **프로모션 범위 팩트** | 날짜 키(FK), 제품 키(FK), 지점 키(FK), 프로모션 키(FK), 프로모션 수 (= 항상 1) |

### ✅ 특징

- 측정값(Measure)이 없음 → **팩트 없는 팩트 테이블**
- 경우에 따라 측정값처럼 항상 `1` 값을 가지는 **더미 팩트**를 추가
    - 예: `프로모션 수` → 프로모션 대상 수를 세기 위해 사용

### 📊 활용

1. 프로모션 범위 팩트 테이블 → 특정 날짜의 **프로모션 대상 제품 목록** 추출
2. 판매 팩트 테이블 → 실제 판매된 제품 목록 추출
3. 두 목록의 차집합 → 프로모션이 있었지만 **판매되지 않은 제품 목록** 도출

### 📌 2. 대체 키 (Surrogate Key)

### ❓ 왜 사용하는가?

- 운영 시스템의 **원천 키(Natural Key)**는 불안정하거나 여러 시스템 간 충돌 가능성
- **데이터 웨어하우스**에서는 독립적으로 관리되는 **의미 없는 정수형 키**가 더 안전하고 효율적

### 🔍 대체 키의 장점

| 장점 | 설명 |
| --- | --- |
| 🔧 운영 시스템 변경과 무관 | 운영 시스템에서 코드 변경, 복원 등 발생해도 영향 없음 |
| 🔗 다중 원천 시스템 통합 | 서로 다른 시스템의 키를 공통 대체 키로 매핑 |
| ⚡ 성능 향상 | 작은 정수형 키 → 인덱스 크기 최소화, I/O 최적화 |
| 🕵️ 널 값 및 예외 처리 | ‘알 수 없는 고객’ 등 운영 시스템에는 없는 값을 지정 가능 |
| 📈 변경 이력 관리 | 동일 원천 키에 대해 속성 변경 시 새로운 대체 키 부여 가능 (SCD 관리에 필수) |

### 💡 예시

- `제품 디멘션`: SKU 번호 대신 `제품 키(PK)`를 정수형으로 생성
    - SKU 번호는 운영 키(Natural Key), `제품 키`는 대체 키(Surrogate Key)

### 🧠 유의사항

- 데이터 모델에서 **모든 조인은 대체 키 기반으로 설계**해야 함
- 쿼리나 애플리케이션에서 **대체 키에 직접 의존하지 않도록 주의**

## 1️⃣ 퇴화 디멘션과 대체 키

### 💡 개념 요약

- **퇴화 디멘션 (Degenerate Dimension)**: 별도 디멘션 테이블 없이 팩트 테이블에 존재하는 디멘션 속성.
- **대체 키 필요 여부**는 다음의 경우에 고려:
    - 트랜잭션 관리 번호가 **위치에 따라 유일하지 않음**.
    - 트랜잭션 번호가 **재사용**되거나 **초기화**됨.
    - 트랜잭션 번호가 복잡한 **문자/숫자 조합**인 경우.
    - **드릴 어크로스**(사이팩트 분석)를 위해 별도 디멘션 테이블 필요.

✅ **중요**: 대체 키와 디멘션 테이블을 따로 만들게 되면 **더 이상 퇴화 디멘션이 아님**.

## 2️⃣ 일자 디멘션의 스마트 키

### 💡 특징 및 설계 전략

| 항목 | 설명 |
| --- | --- |
| **일자의 특성** | 고정되어 있고, 미래에 예측 불가능한 값이 생성되지 않음 |
| **스마트 키의 설계** | YYYYMMDD 형식 or 순차 정수 (예: 1월 1일 → 1, 1월 2일 → 2 등) |
| **장점** | 파티셔닝, 관리 편의성, 날짜 정렬 효과 |
| **단점** | 날짜 속성은 BI 앱에서 조회해야 하므로 쿼리 성능 저하 가능 |

### 📌 DATE 타입 vs YYYYMMDD 스마트 키

- **DATE 타입**은 일부 DB의 옵티마이저에서 더 효율적으로 작동.
- **YYYYMMDD 정수 키**는 파티션 관리, 인덱싱, ETL 운영에 유리.

📍 **Tip**: 최초 적재 시 날짜 누락 가능성 대비 → "Unknown Date Key" 준비 필요.

## 3️⃣ 팩트 테이블의 대체 키

### 💡 언제 사용하나?

ETL의 안정성과 효율성을 위해, 팩트 테이블에도 별도의 정수 기반 대체 키를 사용할 수 있음.

### ✅ 기대 효과

| 목적 | 설명 |
| --- | --- |
| **고유 식별자** | 디멘션 조인 없이도 개별 팩트 로우 식별 가능 |
| **에러 복구 지원** | 적재 중단 시 마지막 키 기반으로 복구 가능 |
| **INSERT + DELETE로 UPDATE 대체** | 성능 효율적이며 트랜잭션 관리 용이 |

### 📘 고급 설계: 부모-자식 팩트 테이블 관계

- 부모 테이블의 **대체 키**를 자식 팩트 테이블에 **외래 키**로 포함.
- 자식 팩트 테이블은 부모 팩트의 디멘션 키도 함께 포함시켜야 함 → **슬라이스 & 다이스 지원**.
- ⚠️ **팩트 테이블 간 조인은 지양** (추후 '4장 재고'에서 상세 설명 예정).

## 4️⃣ 정규화 회피 전략

### 💡 목적

- 사용자 친화성 + 성능 향상을 위해 다차원 모델은 **정규화 원칙을 의도적으로 피함**.

### 주요 전략

- **반정규화된 디멘션** 테이블 설계 (스노우플레이크 모델 대신 스타 스키마 지향)
- 반복되는 값을 포함하더라도 **통합된 디멘션 테이블 유지**
- **문자 기반 속성**도 한 테이블에 모아서 조회 편의성 제공

📍 **Tip**: 운영 시스템 중심의 모델러에게는 이 방식이 낯설 수 있음 → 사용자 중심 모델링 필요성 이해해야 함.

## ✅ 아웃리거 디멘션 (Outrigger Dimension)

### 1. **정의**

- **아웃리거 디멘션**은 **디멘션 테이블의 속성이 또 다른 디멘션 테이블을 참조**하는 구조입니다.
- 일반적으로 권장되지 않지만, 특정 상황에서는 **팩트에 대한 추가 설명을 제공하는 디멘션**으로 허용됩니다.

### 2. **예시**

- `제품 디멘션`에 포함된 `제품 출시 일자 키(FK)` → `제품 출시 일자 디멘션` 참조 (그림 3-16).
- 이 경우, 출시 일자에 대한 **회계 연도/분기, 휴일 여부 등 비정형적인 속성**을 별도로 관리함.

### 3. **사용 목적**

- **비즈니스적 의미가 있는 일자 속성**(예: 회계월, 공휴일 구분 등)을 다룰 때 활용.
- 비즈니스 사용자들이 **필터링/그룹핑**에 활용하기 좋은 형태로 제공.

### 4. **구성 방식**

- 아웃리거 대신 디멘션 안에 **속성으로 포함**하는 것도 대안.
- 아웃리거가 되더라도 **해당 속성의 값은 표준 일자 디멘션 범위 내여야 함**.

### 5. **장점**

- 저장 공간 절약.
- 동일 속성 참조 시 **일관성 유지**.

### 6. **단점**

- 성능 저하 (조인 증가).
- 모델 이해도 저하 (사용자가 혼란스러워함).
- **디멘션 내 속성 간 관계 탐색이 어려움**.

### 7. **정리**

- 아웃리거는 **예외적인 경우에만 허용**.
- 일반적인 다차원 모델링에서는 **지양하는 구조**.

## 🐛 지네 팩트 테이블 (Centipede Fact Table)

### 1. **정의**

- **지나치게 많은 디멘션**(보통 25개 이상)이 **하나의 팩트 테이블**에 연결된 형태.
- 마치 **지네(centipede)**처럼 많은 외래 키(FK)를 가진 팩트 테이블을 의미.

### 2. **문제 상황**

- 예: `일자키`, `주키`, `월키`, `분기키`, `회계연키`, `회계월키`, `지점 관련 디멘션 키`, `제품 관련 디멘션 키`, `프로모션 키`, `브랜드 키` 등 매우 많은 FK가 존재 (그림 3-17).

### 3. **발생 원인**

- 디멘션 정규화를 **팩트 테이블로 대체하려는 잘못된 시도**.
- 디멘션 계층(브랜드, 카테고리 등)을 디멘션 테이블 대신 팩트에 직접 포함.

### 4. **문제점**

- **팩트 테이블이 비대해지고 관리 어려움**.
- 조인 성능 저하 및 쿼리 복잡성 증가.
- 많은 FK가 **사용자 경험을 저해**.

### 5. **해결 방법**

- 디멘션 간 연관 관계가 있다면 **하나의 디멘션으로 통합**.
- 분리된 디멘션이 유사하거나 완전히 관련된 속성이라면 **통합 디멘션 생성**.
- **카티시언 프로덕트(Cartesian Product)** 발생 위험을 줄이기 위해 관련 속성은 묶어야 함.

### 6. **칼럼 기반 DB의 도움**

- 칼럼 단위로 저장되므로 **불필요한 칼럼은 조회하지 않음**.
- 지네 팩트 테이블의 성능 문제를 **부분적으로 완화 가능**.
- 그러나 여전히 **계층 구조의 의미 파악은 어려움**.

### 7. **정리**

- 팩트 테이블에는 일반적으로 **20개 이하의 디멘션**이 연결되는 것이 바람직.
- 25개 이상의 디멘션이 연결된다면 **모델링 오류 가능성**을 반드시 점검.