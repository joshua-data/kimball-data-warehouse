# 기본 개념

### 비즈니스 요구사항과 데이터 현황 수집

**핵심 요약**

- 다차원 모델링은 "설계"이기 전에 "이해"가 먼저입니다.
- **현업 담당자**와의 미팅 → KPI, 의사결정 방식, 분석 요구사항 수집
- **IT/시스템 담당자**와 협업 → 원천 데이터 프로파일링 수행

**실무 팁**

- 현업에게 "최근에 어떤 보고서를 만들었는지", "엑셀에서 자주 피벗하는 열은 무엇인지" 물어보면 빠르게 파악할 수 있습니다.
- 원천 데이터 프로파일링은 `Null`, `데이터 타입`, `범위`, `정합성` 체크로 시작해보세요.

### 다차원 모델링 워크숍

**핵심 요약**

- 모델링은 **혼자서 하지 않는다!**
- 모델러, 현업, 데이터 거버넌스 팀이 같이 참여하는 **워크숍 기반 공동 설계**가 중요
- 이때 **비즈니스 용어 정의**가 정리되면 아주 좋습니다

**실무 팁**

- "이 컬럼 이름이 우리 회사에서 흔히 쓰는 용어인가요?" 같은 질문이 실마리를 줍니다.

### 4단계 다차원 설계 프로세스

**1) 비즈니스 프로세스 선택**

- 예: 주문 처리, 제품 출하, 광고 클릭, 앱 설치 이벤트 등
- **팩트 테이블이 무엇을 기록할지**를 결정하는 핵심 기준

**2) 그레인 정의**

- 팩트 테이블의 한 행이 **무엇을 나타내는지 정확히 정의**
- 예: "사용자 1명이 특정 시간에 클릭한 광고 이벤트 1건"

> ⚠️ 그레인을 먼저 확정한 후, 디멘션과 팩트를 정해야 합니다.
> 

**3) 디멘션 식별**

- "누가, 언제, 어디서, 무엇을, 어떻게, 왜"를 설명하는 컨텍스트
- 예: 사용자, 날짜, 제품, 지역, 캠페인

**4) 팩트 식별**

- **측정값**, 즉 숫자 (금액, 수량, 횟수 등)
- 예: 결제 금액, 조회 수, 클릭 수, 매출 등

### Dimension의 역할

**핵심 요약**

- 디멘션은 팩트를 설명해주는 텍스트 기반의 배경정보
- 보고서에서 **필터**와 **그룹 기준**으로 가장 많이 사용됨
- BI에서 가장 **사용자 친화적인 테이블**

**실무 팁**

- 디멘션 테이블에는 항상 **Business Label** (ex: `user_name`, `product_category_name`)이 포함되어야 합니다.
- 계층 구조(`대분류-중분류-소분류`)가 있는 경우, 이를 컬럼으로 분해하면 피벗하기 쉬워집니다.

### Fact의 역할

**핵심 요약**

- 팩트는 "측정값"
- 한 행이 하나의 비즈니스 이벤트에 대한 정량적인 결과
- 숫자 중심이지만, 외래 키도 반드시 포함

**실무 팁**

- 팩트 테이블의 칼럼 중, 누적/집계가 가능한 수치만 남기는 것이 좋습니다.
- 비집계 속성(ex: ‘결제 방식’, ‘성공 여부’)은 디멘션으로 분리하는 게 분석에서 더 유연합니다.

### Star Schema와 OLAP Cube

| **개념** | **설명** |
| --- | --- |
| **Star Schema** | RDBMS 기반, 팩트 테이블을 중심으로 디멘션 테이블들이 방사형으로 연결됨 |
| **OLAP Cube** | 다차원 DB(MOLAP, HOLAP 등) 기반, MDX 또는 XMLA로 접근 |

**실무 팁**

- 대부분의 현대적인 BI 툴 (Metabase, Redash, Looker, Tableau)은 RDBMS의 스타 스키마를 기반으로 동작합니다.
- OLAP 큐브는 SQL 기반 분석이 어려운 경우, 또는 대규모 pre-aggregation이 필요한 시나리오에만 사용합니다.

### 다차원 모델의 유연한 확장성

**핵심 요약**

- **기존 구조 변경 없이도** 확장 가능
    - 팩트 컬럼 추가
    - 디멘션 테이블 확장
    - 새로운 디멘션 추가
- 이것이 Kimball 모델의 최대 장점

**실무 팁**

- 신규 요구사항이 생기면 먼저 **기존 그레인을 확인**한 다음 확장하세요.
- 항상 변경은 기존 BI 쿼리의 영향을 최소화하는 방식으로 설계해야 합니다.

---

# Fact 테이블 기본 기법

### 📘 팩트 테이블 기본 기법 요약 정리

**1. 📊 팩트 테이블이란?**

- 실세계의 **운영 업무 활동**에서 생성된 숫자형 측정값(measure)들을 저장하는 테이블.
- 항상 **디멘션의 외래키(FK)** 와 함께, **날짜/시간 정보**, **퇴화 디멘션 키**를 포함.
- 일반적으로 **쿼리의 집계 대상이 되는 핵심 테이블**.

**2. ➕➖ 합산 가능성에 따른 팩트 분류**

| **분류** | **설명** | **예시** |
| --- | --- | --- |
| **✅ 합산 가능** | 모든 디멘션 기준으로 합산 가능 | 수량, 매출액 등 |
| **☑️ 부분 합산 가능** | 일부 디멘션 기준으로만 합산 가능 | 잔고, 재고 수량 |
| **❌ 합산 불가** | 디멘션에 관계없이 합산 자체가 불가능 | 평균, 비율 등 |

> 📌 합산 불가 팩트는 집계 가능한 요소들을 따로 저장해서, 나중에 계산하는 것이 좋음 (예: BI 툴 or OLAP 엔진)
> 

**3. ❌ 팩트 테이블에서 NULL 값 처리**

- **측정값 컬럼에 NULL**은 괜찮음 → `SUM`, `AVG`, `COUNT` 등에서 문제 없음
- 하지만 **참조 키(디멘션 FK)에는 NULL을 피해야 함**
    - 해결법: ‘알 수 없음(Unknown)’ 값을 가진 Dimension Row를 만들어 연결

**4. 🧩 표준 팩트 정의**

- **같은 이름의 측정값**이 다른 팩트 테이블에 있다면, 정의가 **정확히 일치하는지 확인**
    - 동일 정의 → 같은 이름 사용 (표준화)
    - 다른 정의 → 사용자 혼란 방지 위해 **다른 이름 부여**

### 📐 팩트 테이블 유형

**🧾 Transactional Fact Table**

- **가장 기본적이고 상세한 형태**
- 하나의 Row = **하나의 업무 이벤트**
- 특징:
    - 그레인: 개별 트랜잭션
    - 측정값은 반드시 해당 트랜잭션과 일치해야 함
    - 가장 다양하게 조합 가능한 구조

**🗓️ Periodic Snapshot Fact Table**

- 일정 기간(일/주/월 등) 동안의 활동을 요약한 테이블
- 그레인 = 기간 단위
- 특징:
    - 한 기간에 대한 여러 측정값 포함 가능
    - 활동이 없더라도 0 또는 NULL로 채워서 **균일한 밀도 유지**

**🛠️ Accumulative Snapshot Fact Table**

- **프로세스의 단계별 상태 변화**를 추적하는 테이블
- 예: 주문 처리, 클레임 처리 등
- 특징:
    - Row는 처음 한 번 생성 → 처리 단계별로 **업데이트**
    - 주요 단계(주문일, 발송일, 배송일 등)의 날짜 키를 포함
    - 소요 시간, 완료 여부 등의 측정값 포함

**🔎 Factless Fact Table**

- **측정값 없이 이벤트 존재 자체만 기록**
- 예: 강의 출석, 고객 접촉 이력
- 사용 예:
    - 발생한 이벤트 vs 발생하지 않은 이벤트 분석 가능

**🧮 Aggregate Fact Table**

- **최소단위 팩트 테이블을 Roll-up**한 형태 (예: 일 → 월, 매장별 → 국가별)
- 특징:
    - BI 쿼리 성능 향상 목적
    - OLAP 큐브처럼 **비즈니스 사용자 접근은 제한적**, 주로 백엔드에서 자동 활용됨
    - **축소된 디멘션 키** + **요약된 측정값**

**🔄 Conformed/Integrated Fact Table**

- **여러 프로세스의 데이터를 하나의 그레인**으로 통합한 팩트 테이블
- 예: 판매 실적 + 예측 데이터 통합 → 계획 대비 실적 분석
- 장단점:
    - ❗ ETL 복잡도는 증가
    - ✅ BI 분석 측면에서는 효율적

---

# Dimension 테이블 기본 기법

### ✅ 1. 디멘션 테이블 구조

- 기본 키(PK)를 가짐 → 팩트 테이블에는 이 값이 외래 키(FK)로 연결됨.
- 대부분의 디멘션은 **낮은 Cardinality**의 **텍스트 속성**으로 구성됨.
- **풍부한 설명 텍스트**가 포함되어야 함 (예: "M" → "Male").
- BI 리포트의 **Filter, Grouping, Labeling**에 활용됨.
- **반정규화**되어 있는 것이 일반적이며, 조인을 줄이고 쿼리 속도를 높임.

### ✅ 2. 디멘션 대체 키 (Surrogate Key)

- 운영 시스템의 원천 키를 그대로 사용 ❌
- 의미 없는 **순차적인 정수값**으로 **디멘션 고유 키** 생성 ✅
- 이유:
    - 하나의 원천 키에 여러 버전(타임라인)이 생길 수 있음.
    - 운영 시스템 간 키 충돌 가능성 있음.
- 예외: **일자 디멘션**은 의미 있는 키(YYYYMMDD 등)를 사용해도 됨.

### ✅ 3. 영속성 보장 대체 키 (Durable Surrogate Key)

- 예: 직원이 퇴사 후 재입사 → 사번(운영 키)이 바뀜.
- 영속 키는 한 인물의 **시간이 지나도 변하지 않는 고유 ID** 역할.
- 내부적으로는 변경되는 surrogate key들과 매핑 가능.

### ✅ 4. 드릴 다운 (Drill Down)

- BI 사용자 분석을 위해 **GROUP BY**에 디멘션 속성을 추가하는 방식.
- 사전 정의된 계층 없어도 가능.
- 팩트 테이블과 연결된 디멘션 속성을 사용함.

### ✅ 5. 퇴화 디멘션 (Degenerate Dimension)

- 디멘션 테이블 없이 팩트 테이블 안에 포함된 속성.
- 예: 송장번호, 주문번호 등 → 별도 디멘션 내용이 없고, 팩트에 직접 존재.

### ✅ 6. 반정규화 디멘션

- 계층 정보(예: 국가 → 지역 → 도시)를 **한 Row에 Column으로 포함**.
- 조인 성능을 줄이고, **사용자 친화적인 쿼리** 제공.
- 정규화 유혹을 버리고 반정규화를 선택하는 것이 권장됨.

### ✅ 7. 다중 계층 디멘션

- 하나의 디멘션에 **복수의 계층 구조**가 존재.
- 예: 일자 → [일-주-분기-회계연도] / 지역 → [도시-주-국가].
- 같은 테이블 안에 다양한 계층의 컬럼을 반정규화로 표현.

### ✅ 8. 플래그와 분류 값

- 예: "Y", "N", "U" → "Yes", "No", "Unknown"
- 코드 값은 **의미 있는 텍스트로 확장**하여 저장.
- BI 사용자에게 직관적인 분석이 가능하도록 제공.

### ✅ 9. 디멘션의 널 값 처리

- NULL은 **'알 수 없음', '미정'** 등 명시적인 텍스트로 대체.
- 데이터베이스마다 NULL 처리 방식이 달라서 쿼리 이슈가 발생할 수 있음.

### ✅ 10. 달력 디멘션 (Date Dimension)

- 날짜, 월, 회계기간, 요일, 국가휴일 등 다양한 날짜 정보 포함.
- 팩트 테이블은 SQL에서 날짜 속성을 파싱하지 않고 **디멘션 테이블로 연결**.
- 일자 키는 보통 `YYYYMMDD` 형식의 **정수**로 표현.
- "알 수 없음", "TBD" 같은 특별한 날짜도 포함.

### ✅ 11. 롤 플레잉 디멘션 (Role-Playing Dimension)

- 하나의 디멘션이 팩트 테이블에서 **여러 역할로 사용**.
- 예: 주문일자, 배송일자, 청구일자 → 모두 같은 일자 디멘션을 참조하되, **칼럼 이름은 다르게 구분**.

### ✅ 12. 정크 디멘션 (Junk Dimension)

- Cardinality가 낮은 플래그, 코드들을 **하나의 디멘션으로 통합**.
- 예: 주문 채널, 프로모션 유무, 고객 유형 등 → 모두 하나의 "정크 디멘션"에 저장.
- 가능한 조합만 포함하여 관리 효율화.

### ✅ 13. Snowflake 디멘션

- 정규화를 통해 계층별로 테이블을 나눔 (예: 도시 → 지역 테이블 → 국가 테이블).
- 하지만 사용성과 성능이 떨어짐 ❌
- 보통은 **반정규화**를 권장함.

### ✅ 14. 아웃트리거 디멘션 (Outrigger Dimension)

- 디멘션 내에서 **다른 디멘션을 참조**.
- 예: 계좌 디멘션 → 개설일자 참조를 위해 날짜 디멘션 연결.
- 가능한 한 피하는 것이 좋음. 대신, 팩트 테이블에서 두 디멘션을 모두 참조하는 방식으로 해결 권장.

---

# 표준 Dimension을 통한 통합

### 1. 표준 디멘션(Standard Dimension)이란?

- **정의**: 서로 다른 비즈니스 프로세스에서 사용되는 디멘션 테이블이 **같은 의미, 같은 구조**를 가지도록 표준화된 디멘션입니다.
- **예시**:
    - `dim_date`: 전체 시스템에서 날짜 기준이 동일하게 사용됨
    - `dim_customer`: 구매, 콜센터, 마케팅 등 다양한 부서에서 같은 고객 정보를 공유

### 2. 왜 중요한가요? (표준 디멘션의 장점)

| 목적 | 설명 |
| --- | --- |
| 🔗 **데이터 통합** | 여러 팩트 테이블이 동일한 디멘션을 참조함으로써 **데이터를 하나로 합쳐서 분석** 가능 |
| 📊 **드릴 어크로스(Drill Across)** | 공통 디멘션 속성을 기준으로 서로 다른 팩트 테이블의 데이터를 **같은 리포트에 병렬로 표현** 가능 |
| 🔁 **재사용과 일관성** | 디멘션 재사용 → 개발 시간 단축 + 데이터 의미의 일관성 유지 |
| 💰 **비용 절감** | 중복 디멘션 개발 방지, 유지보수 용이 |

### 3. 표준 디멘션이 적용된 구조: 전사 데이터 웨어하우스 버스 아키텍처 (Bus Architecture)

- **구조**:
    - **행(Row)**: 각 비즈니스 프로세스 (예: 주문, 결제, 반품 등)
    - **열(Column)**: 표준 디멘션 (예: 고객, 제품, 날짜 등)
- **활용**:
    - 어느 프로세스에서 어떤 디멘션을 참조하는지 한 눈에 볼 수 있어 설계 및 협업이 쉬움

### 4. 드릴 어크로스(Drill Across) 기법

- **정의**: 서로 다른 팩트 테이블에서 **공통 디멘션**을 기준으로 결과를 나란히 보여주는 쿼리 방법
- **예시**:
    - `fact_sales`와 `fact_support_calls`가 모두 `dim_customer`와 연결되어 있다면,
        
        고객 기준으로 매출액과 고객문의건수를 **같은 리포트**에서 나란히 조회 가능
        

### 5. 축소 디멘션(Shrunken Dimension)

- **정의**: 표준 디멘션의 **부분집합** (칼럼 또는 로우 기준으로 축소됨)
- **활용 예시**:
    - `dim_product` → `dim_brand` (브랜드만 유지)
    - `dim_date` → `dim_month` (월 단위만 유지)
- **용도**:
    - 요약 팩트 테이블(예: 월간 요약, 브랜드별 예측)에서 사용
    - 더 높은 레벨의 분석과 성능 최적화에 유용

### ✅ 표준 디멘션이 특히 중요한 상황

- 이질적인 데이터를 **한 리포트로 통합**하고자 할 때
- 여러 팀(또는 시스템) 간 **협업**이 필요한 리포트가 있을 때
- **DW/BI 시스템의 단계적 구축**이 필요할 때 (애자일 방식 적용 가능)

---

# **SCD (Slowly Changing Dimension) 관리 속성 정리**

### ✅ Type 0: 최초 값 유지 (Original value preserved)

- **의미**: 변경이 발생해도 원래의 값을 절대 변경하지 않음.
- **활용 예**:
    - 고객 최초 신용점수
    - 고정적인 식별자 (예: 가입 당시 국가, 고객번호 등)
- **장점**:
    - 데이터 정합성 유지
- **단점**:
    - 변경 필요 시 유연성 부족
- **Tip**: 컬럼명에 `original_` prefix를 붙여 관리

### ✅ Type 1: 덮어쓰기 (Overwrite)

- **의미**: 기존 값을 새 값으로 **업데이트** (이력은 남지 않음)
- **활용 예**:
    - 고객 이메일 주소
    - 최근 연락처
- **장점**:
    - 구현이 간단, 디멘션 테이블 사이즈 증가 없음
- **단점**:
    - 과거 데이터의 정확성 손상 가능
- **주의**:
    - 집계 데이터를 재계산해야 할 수도 있음

### ✅ Type 2: 신규 로우 추가 (New row per change)

- **의미**: 변경이 발생할 때마다 **새로운 로우** 추가, 과거 이력 모두 유지
- **필수 속성**:
    1. 유효 시작일 (`effective_date`)
    2. 유효 종료일 (`end_date`)
    3. 현재 로우 여부 플래그 (`is_current`)
- **활용 예**:
    - 고객의 주소 변경 이력
    - 직급 변경 이력
- **장점**:
    - 이력 유지 가능
- **단점**:
    - 디멘션 테이블 크기 증가
- **팁**:
    - surrogate key (대체키) 활용 필요

### ✅ Type 3: 신규 속성 추가 (Add new column)

- **의미**: 과거 값을 별도 컬럼으로 저장 (ex: `current_region`, `previous_region`)
- **활용 예**:
    - 최근/이전 캠페인 참여 지역
- **장점**:
    - 과거 값과 현재 값을 함께 보여줄 수 있음
- **단점**:
    - 이력 관리가 1~2번까지만 가능 (확장성 부족)

### ✅ Type 4: 미니 디멘션 (Mini Dimension)

- **의미**: 빠르게 변하는 속성만 따로 테이블로 분리
- **활용 예**:
    - 고객의 성향, 선호도, 행동 패턴
- **장점**:
    - 디멘션 테이블 크기 최적화
- **단점**:
    - 조인 복잡성 증가
- **사용 방법**:
    - 미니 디멘션과 베이스 디멘션의 surrogate key를 팩트 테이블에 함께 포함

### ✅ Type 5: Type 4 + Type 1 Outrigger

- **의미**: 타입 4(미니 디멘션) + 베이스 디멘션에서 **현재값을 직접 참조**
- **활용 예**:
    - 보고서에서 현재 상태 기준 필터링이 필요할 때
- **장점**:
    - 현재값과 과거값을 동시에 효율적으로 처리
- **ETL 처리 시**:
    - 미니 디멘션의 현재값이 변경되면 베이스 디멘션의 타입 1 속성도 함께 변경

### ✅ Type 6: Type 1 + Type 2

- **의미**: 타입 2처럼 **로우 추가**, 동시에 타입 1처럼 **현재 값 컬럼** 추가
- **활용 예**:
    - 이전 지역(`region`), 현재 지역(`current_region`) 둘 다 필요할 때
- **장점**:
    - 유연하게 과거와 현재 기준 보고서 작성 가능
- **단점**:
    - ETL 복잡도 증가
- **ETL 처리 시**:
    - 속성 변경 시, 같은 surrogate key 그룹 전체에 현재 값 컬럼을 갱신

### ✅ Type 7: Type 1 디멘션과 Type 2 디멘션 병행

- **의미**: 타입 1과 타입 2 디멘션을 **각각 따로 유지**하고, 팩트 테이블에 **두 키**를 모두 보유
- **활용 예**:
    - 최신 기준 리포트와 이력 기준 리포트를 모두 제공해야 하는 경우
- **장점**:
    - 유연성 극대화
- **단점**:
    - 설계 및 유지 보수 복잡도 ↑
- **팁**:
    - BI 툴에서는 두 디멘션을 각각 다른 뷰로 노출

### 📘 참고 팁

- 실무에서는 **한 디멘션에 여러 타입의 속성을 혼합**해서 사용하는 경우가 많습니다.
    - 예: 고객 주소 → 타입 2 / 고객 이름 → 타입 1 / 최초 국가 → 타입 0
- Kimball의 가이드에 따르면, 타입 2와 6이 **가장 널리 사용됨**
- 모든 유형의 이력 관리는 **Surrogate Key 설계가 핵심**입니다!

---

# Dimension 계층 다루기

디멘션 계층(Dimension Hierarchy)은 데이터 웨어하우징에서 분석의 깊이와 방향을 결정짓는 중요한 요소입니다. 아래는 다양한 계층 관리 기법들과 각각의 특징을 설명한 내용입니다.

### 1. 🧱 고정 레벨 계층 (Fixed-Level Hierarchy)

**🔹 설명**

- 예: 제품 → 브랜드 → 카테고리 → 제품 분류
- 각 레벨이 **명확한 다대일 관계**로 구성됨

**🔹 특징**

- 레벨 수와 구조가 일정
- 디멘션 테이블에 **별도 컬럼으로 각 레벨 속성 저장**
- 성능이 뛰어나고 이해하기 쉬움
- 분석에 매우 예측 가능하게 사용 가능

**🔹 적용 예시**

- 조직 구조, 제품 분류, 회계 항목 분류 등

### 2. 🌀 소규모 불규칙 / 가변 레벨 계층 (Small-Scale Ragged / Variable-Depth Hierarchy)

**🔹 설명**

- 예: 국가 → 지역 → 도시 → 동네 → 거리
- 레벨 수가 일정하지 않지만 **범위는 작고 예측 가능** (예: 3~6단계)

**🔹 특징**

- 최대 레벨 수 기준으로 컬럼 생성
- 부족한 레벨은 NULL 또는 공백으로 채움
- 비즈니스 규칙에 따라 강제로 고정 레벨로 맞춤

**🔹 장점**

- 복잡한 브리지 테이블 없이도 간단하게 구현 가능

### 3. 🌉 브리지 테이블을 활용한 불규칙 / 가변 계층 (Bridge Table for Ragged / Variable-Depth Hierarchy)

**🔹 설명**

- 부모-자식 관계가 반복적으로 이어지는 **복잡한 트리 구조** (ex: 조직도, 제품 트리 등)

**🔹 특징**

- 재귀 쿼리 없이도 **모든 경로를 표현**하는 브리지 테이블 사용
- 브리지 테이블은 계층 내 가능한 모든 탐색 경로를 포함
- SQL 표준으로도 탐색 가능 → **쿼리 성능 우수**
- 공유 구조나 계층 변경 시간도 관리 가능

**🔹 장점**

- 표준 SQL만으로도 유연한 계층 탐색 가능
- ETL에서 경로 미리 생성 가능

### 4. 🧭 전체 경로 속성을 가지는 계층 (Path String Hierarchy)

**🔹 설명**

- 디멘션 테이블 내에 각 로우마다 계층의 전체 경로를 문자열로 저장
- 예: `/대한민국/서울/강남구/역삼동`

**🔹 특징**

- 구조: 전체 계층 경로를 `delimiter`로 구분한 문자열로 저장
- 쿼리에서 `LIKE` 또는 `REGEXP` 등을 통해 탐색 가능

**🔹 장점**

- SQL 표준만으로 분석 가능
- 단일 디멘션 테이블로 구현 가능

**🔹 단점**

- 계층 변경 시 전체 경로 재작성 필요
- 공유 구조 및 복잡한 탐색에는 부적합

---

# 고급 Fact 테이블 기법

### 1. **팩트 테이블 대체 키**

- **목적**: ETL 관리 편의, 식별자 부여, 업데이트 안정성 확보
- **사용 이유**:
    - 각 로우를 쉽게 식별 (디멘션 없이도 가능)
    - 적재 실패 시 롤백 또는 재시작이 용이
    - `INSERT + DELETE` 방식으로 갱신 → 리스크 감소

### 2. **지네 팩트 테이블 (Centipede Fact Table)**

- **문제점**:
    - 일자/월/분기/연도 등 계층형 디멘션을 개별적으로 팩트 테이블에 넣는 것
    - 너무 많은 외래 키 → 설계 복잡, 성능 저하
- **권장 방식**: 하나의 디멘션 (예: `일자`)에서 상위 계층 값을 함께 관리

### 3. **팩트 or 디멘션 속성 구분이 어려운 숫자 값**

- **판단 기준**:
    - 계산 목적 → 팩트
    - 필터/그룹핑 목적 → 디멘션 속성
- **예외 처리**: 숫자 속성이 양쪽에서 모두 유용할 경우, **이중 저장** 가능

### 4. **Lag/소요시간 팩트**

- **적용 상황**: 주문 처리, 보험 인수 심사처럼 **단계별 진행 시간**이 중요한 경우
- **설계 팁**:
    - 시작~단계까지의 누적 시간 저장
    - → 임의의 단계 간 차이 = 두 시간값의 차

### 5. **헤더/라인 팩트 테이블**

- **설명**: 주문과 같은 헤더-라인 구조에서, **라인 레벨**이 팩트 테이블로 쓰임
- **설계 팁**: 헤더 레벨 디멘션도 라인 팩트 테이블에 포함해야 함

### 6. **배부 팩트**

- **문제점**: 헤더 레벨의 운임료처럼 라인과 다른 그레인
- **해결**: **비즈니스 규칙**에 따라 라인 레벨로 강제 배부 → 디멘션 기반 분석 가능

### 7. **배부 기반 손익 팩트 테이블**

- **핵심 방정식**: 이익 = 매출 - 비용
- **특징**:
    - 최저 그레인에서 손익을 구현 → 유연한 수익성 분석 가능
- **주의**: 비용 배부 논리는 **복잡하고 정치적**이므로, 초기 DW 구축 시에는 피할 것

### 8. **다중 통화 팩트**

- **설계 방법**:
    - 하나의 로우에 두 개의 통화 기준 값 저장:
        - **원 거래 통화 값**
        - **표준 통화 환산 값**
    - `통화 디멘션`도 필요

### 9. **다중 측정단위 팩트**

- **예시**: 개별, 박스, 팔레트 단위로 동시에 보고 싶을 때
- **해결책**:
    - 표준 단위로만 저장
    - → 환산 계수(`conversion factor`) 저장하여 필요 시 계산

### 10. **YTD 팩트**

- **문제점**: 다양한 YTD 정의 존재
- **권장 해결책**: YTD 값을 팩트 테이블에 저장 ❌
    
    → **BI Tool**이나 **OLAP Cube**에서 계산하도록 함
    

### 11. **팩트 테이블 간 직접 조인 금지**

- **이유**: RDBMS 조인 시 **Cardinality 폭증 위험**
- **대안**: **Drill Across**
    - 각 팩트 테이블 개별 집계 → 공통 디멘션으로 정렬 후 병합

### 12. **팩트 테이블의 시간 범위 추적**

- **사용 상황**: 천천히 변하는 팩트 (ex. 재고 잔고)
- **설계 요소**:
    - `유효시작일`, `만료일`, `현재 로우 여부`
    - → Dimension Type 2처럼 시간 유효성 추적 가능

### 13. **지연 처리 팩트**

- **상황**: 팩트가 들어올 때 디멘션이 아직 매칭되지 않음
- **해결 방법**:
    - 당시 시점의 디멘션 값을 찾기 위한 **look-up** 및 **타임 트래킹 로직**이 필요

---

# 고급 Dimension 테이블 기법

### ✅ 1. 디멘션 간 조인 (Outrigger Dimension)

**✔ 개념**

- 디멘션이 다른 디멘션을 참조할 때 사용하는 방식.
- 예) `고객 디멘션` 안에 `지역 디멘션`의 외래 키를 포함시키는 경우.

**✔ 주의사항**

- Type 2 방식 사용 시, 아웃리거 디멘션이 변경될 때마다 베이스 디멘션이 증가하여 **데이터 폭발** 발생 가능.
- 해결책: **팩트 테이블에서 디멘션을 조인**하도록 설계 → 디멘션 간 결합을 팩트 테이블로 통해서만 확인.

### ✅ 2. 다중 값 디멘션과 브리지 테이블

**✔ 개념**

- 하나의 팩트에 여러 디멘션 값이 매핑될 경우 사용.
- 예) 환자가 동시에 여러 질병 진단을 받을 경우.

**✔ 설계**

- 브리지 테이블을 도입 → 다대다 관계를 연결
- 시간에 따라 변하는 경우: 브리지 테이블에 `유효 시작/종료 일자` 포함 + 스냅샷 시점 조건 필수

### ✅ 3. 행동 태그 시계열

**✔ 개념**

- 고객의 행동(예: 구매 이력, 페이지 뷰 등)에 대해 발생한 태그 정보를 시계열로 저장.

**✔ 활용**

- 디멘션 속성으로 위치 기반 시퀀스를 저장
- 문자열로 전체 행동 경로를 저장해 분석에 활용

### ✅ 4. 행동 연구 그룹

**✔ 개념**

- 행동 분석 결과를 **정적인 테이블**로 저장 (고객 영속 키만 포함)

**✔ 활용**

- 쿼리 시 필터로 사용
- 여러 연구 그룹 간의 합집합, 교집합, 차집합 연산 가능

### ✅ 5. 디멘션 속성으로서의 집계 팩트

**✔ 개념**

- 고객이 일정 금액 이상을 사용했는지 여부를 디멘션 속성으로 설정

**✔ 장점**

- BI에서 분석 성능 향상 (대신 ETL의 부담 증가)
- 주로 **구간으로 표현** (예: 소비 금액 → "10만원 이상", "50만원 이상")

### ✅ 6. 동적 값 구간

**✔ 개념**

- 리포트 생성 시점에 동적으로 값 구간을 설정 (예: 잔고 구간 리포트)

**✔ 구현 방식**

- `구간 디멘션 테이블` + 팩트 테이블 간 `BETWEEN` 연산
- 또는 `CASE WHEN` 문 사용 (칼럼 기반 DB에서 성능 좋음)

### ✅ 7. 텍스트 주석 디멘션

**✔ 개념**

- 팩트 테이블에 주석을 직접 넣기보단, **별도 디멘션 테이블**로 분리

**✔ 효과**

- 주석의 재사용 가능성 증가
- 카디널리티가 팩트 로우와 유사하면 디멘션으로 적절

### ✅ 8. 다중 시간대

**✔ 개념**

- 팩트에 대해 `UTC`와 `지역 시간`을 모두 저장

**✔ 설계**

- `두 개의 롤플레잉 날짜 디멘션` 사용하여 두 시간대 관리

### ✅ 9. 측정값 분류 디멘션

**✔ 개념**

- 팩트 테이블에 컬럼이 너무 많고, 각 행에서 채워진 컬럼이 적을 때 사용

**✔ 설계**

- 하나의 팩트에 `측정값 분류`를 속성으로 저장

**✔ 단점**

- 칼럼 간 연산 어려움
- 잘못 사용하면 팩트 테이블 커짐

### ✅ 10. 진행 단계 디멘션

**✔ 개념**

- 웹 페이지 흐름이나 프로세스 흐름의 각 단계를 추적

**✔ 사용 예**

- "현재 어떤 단계인가?"
- "세션 완료까지 몇 단계 남았는가?" 등의 질문에 대응

### ✅ 11. 핫 스와퍼블 디멘션

**✔ 개념**

- 동일한 팩트가 여러 디멘션 복제본과 **선택적으로 결합**되는 경우

**✔ 사용 예**

- 투자자의 각기 다른 속성을 가진 주식 정보를 볼 때

### ✅ 12. 추상화 범용 디멘션

**✔ 개념**

- 매장, 창고, 고객 등 다양한 주체를 하나의 "위치" 디멘션으로 통합

**✔ 주의사항**

- **다차원 모델링에서는 비추천**
- 속성 차이가 크기 때문에 쿼리 성능에 부정적 영향
- ETL 또는 운영시스템에 적합한 방식

### ✅ 13. 감사 디멘션 (Audit Dimension)

**✔ 개념**

- ETL 처리 시 발생하는 메타 데이터를 기록

**✔ 예시**

- ETL 실행 일시
- 오류 정보
- ETL 버전 정보 등

**✔ 장점**

- 규제 대응, 오류 추적에 용이

### ✅ 14. 지연 처리 디멘션

**✔ 개념**

- 디멘션보다 먼저 팩트가 도착할 경우 사용

**✔ 설계**

- 일단 `미정` 값으로 저장하고 나중에 **Type 1 덮어쓰기** 또는 **Type 2 재적재**

---

# 특수 목적 스키마

### ✅ 특수 목적 스키마 (Specialized Schema)

**1. 슈퍼타입 / 서브타입 스키마**

- **설명**: 서로 다른 상품/서비스 유형(이기종 상품)을 하나의 통합된 팩트 테이블로 관리하기 어려운 경우, 공통 속성만 가진 **슈퍼타입** 테이블과, 유형별로 분리된 **서브타입** 테이블로 분리한다.
- **예시**:
    - 은행 시스템에서 **당좌예금**, **모기지**, **대출** 등은 모두 "계좌"이지만 속성과 팩트가 다름.
    - `account_super_fact`는 공통 정보만 담고, `loan_fact`, `mortgage_fact`, `checking_fact` 등은 각각의 서브타입 팩트를 가짐.
- **핵심 포인트**:
    - **슈퍼타입 팩트** = Core Fact Table
    - **서브타입 팩트** = Custom Fact Table
    - 확장성과 유지보수에 유리
    - 다차원 모델에서 너무 다양한 속성이 섞이는 것을 방지

### 2. **실시간 팩트 테이블 (Real-Time Fact Table)**

- **설명**: 전통적인 야간 배치 처리 대신, 거의 실시간에 가까운 데이터 업데이트가 필요한 경우 사용되는 스키마
- **예시**:
    - 웹사이트 클릭스트림, 거래 알림, 재고 상태 모니터링 등
    - `fact_web_clicks_rt` 처럼 최근 몇 분~초 단위로 데이터가 업데이트됨
- **핵심 기술**:
    - **Hot Partition**: 최신 데이터를 메모리에 상주시켜 빠르게 접근 가능
    - **지연 업데이트(Lazy Update)**: 기존 쿼리가 끝난 후에 데이터 갱신
    - DBMS나 OLAP 시스템의 기능에 따라 아키텍처가 달라짐

### 3. **오류 처리 스키마 (Error Event Schema)**

- **설명**: ETL 과정 중 데이터 품질 오류가 발생했을 때, 이를 추적하고 분석할 수 있도록 하는 스키마
- **예시**:
    - `error_event_fact`: 오류가 발생한 건 단위
    - `error_event_detail_fact`: 어떤 테이블/컬럼에서 오류가 났는지 상세 정보 기록
- **핵심 포인트**:
    - 오류 추적, QA 및 ETL 로깅 시스템에 유용
    - 오류 발생 시점, 원인, 참여한 소스 정보 등을 구조화
    - 향후 품질 개선 작업에 핵심 지표로 사용