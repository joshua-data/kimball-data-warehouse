# 📘 Chapter 20 학습 노트: ETL 시스템 설계/개발 프로세스와 Task

ETL 개발은 **DW/BI 프로젝트의 빙산 아래** 숨겨진 고난이도 작업으로, **예상보다 시간과 노력이 많이 소요**됩니다. 본 장은 Kimball 방법론 기반으로 **ETL 시스템을 설계하고 개발하는 10단계의 로드맵**을 제시합니다.

---

## 🧭 ETL 프로세스의 큰 그림

- **목표**: 데이터 추출 → 정제 및 통합 → 전달 → 환경 관리
- **전제 조건**:
    - 디멘션 모델 논리 설계 완료
    - 상위 수준 아키텍처 설계 초안 수립
    - 원천-타깃 데이터 매핑 초안 작성

---

## ✅ ETL 설계 10단계 요약

### 📌 1단계: 상위 수준 계획의 도식화

- 원천 시스템과 타깃 시스템을 연결한 간단한 도식 작성
- 원천 시스템 예시: 30년 된 코볼 시스템 → 타깃 DW
- **도식은 자주 업데이트**하고, 내부/외부용으로 버전 분리
- 의도적으로 **미해결 문제와 리스크를 시각화**해 공유

---

### 📌 2단계: ETL 툴 선택

- **툴의 장점**:
    - 자동 문서화
    - 메타데이터 기반 로직
    - 팀 협업을 위한 버전 관리
    - 고급 데이터 클렌징/정제 지원
    - 성능 최적화 및 병렬처리
- **툴 선택 기준**:
    - 원천 DB의 구조 (관계형인지 아닌지)
    - 내부 개발 리소스 보유 여부
    - 추출 및 변환 로직의 복잡도

✅ **툴 도입 시 초기 학습 곡선이 크지만, 장기적 유지보수에 강력한 이점**

---

### 📌 3단계: 기본 전략 수립

공통적인 활동에 대한 전략 수립:

1. **데이터 추출 방식 결정**:
    - Flat file push
    - Stream 처리
    - DB 로그 리딩 등
2. **Stage 데이터 보관 정책**:
    - 최소 1개월 이상 보관
    - 어떤 조직은 영구 보관
3. **데이터 품질 모니터링 설계**
    - 사용자보다 먼저 이상 탐지
4. **디멘션 속성 변경 관리**
    - SCD 유형별 처리 전략 수립
5. **시스템 가용성 만족**
    - 데이터 가용 시점 문서화
    - 상위 작업 순서 정의
6. **데이터 감사 로직 설계**
    - 데이터 생성/변경 이력 추적 필드 추가
7. **ETL 스테이징 정책 수립**
    - 디스크 기반 백업 및 복구 대비

---

### 📌 4단계: 타깃 테이블 수준으로 상세 계획 수립

- **각 테이블 및 컬럼 단위 변환 로직 정의**
- **데이터 프로파일링** 통해 매핑 정확성 확보

📎 **중요 개념 – 명시적 계층 구조 보장**

- 예: 제품 → 제품 카테고리 → 재고 단위
- 외래키 제약 등으로 계층 구조의 무결성 확보 필요

---

## 🧠 실무 시 주의할 점

| 고려사항 | 설명 |
| --- | --- |
| **원천 데이터 구조** | 레거시 시스템 여부, 스키마 복잡성 등 |
| **ETL 툴 vs. 자체 개발** | 조직의 인력 역량 및 유지보수 비용 고려 |
| **데이터 품질 설계** | ETL 내에서 적극적으로 오류 탐지하고 로깅 |
| **계층 구조 관리** | 디멘션 테이블 설계 시 누락 방지 |
| **스테이징 정책** | 오류 복구, 성능 최적화, 감사 대응 등을 위해 Stage 구간 설계 철저히 |

# ETL 초기 적재 프로세스 개발 학습 노트

---

## 1. 초기 적재 프로세스 개발 개요

- ETL 스펙 작성 완료 후, 과거 데이터를 한 번에 적재하는 초기 적재 프로세스 개발에 집중한다.
- 초기 적재와 변경 적재(증분 적재)를 같은 코드로 처리할 수도 있으나, 보통 별도 프로세스를 운영하는 것이 일반적이다.
- 두 프로세스는 기능상 많은 공통점을 가지며, ETL 도구에 따라 기능이 재사용될 수 있다.

---

## 2. Step 5: 초기 적재 데이터를 활용한 디멘션 테이블 채우기

### 2-1. 디멘션 테이블 유형과 로드

- **타입 1 디멘션**: 최신 속성값으로 덮어쓰기 방식
    - 원천 시스템에서 최신 데이터만 추출하여 적재
    - 가장 간단한 형태이며, 주로 속성 업데이트에 사용됨
- **타입 2 디멘션**: 이력 관리(신규 로우 추가)
    - 시간에 따른 속성 변경 이력 유지
    - 초기 적재 시 과거 이력 재구성이 필요하며, 어렵고 복잡할 수 있음

### 2-2. 데이터 변환 및 정제

- 데이터 타입 변환은 가장 흔하고 중요한 작업
- 널(NULL) 값은 쿼리 시 문제를 일으키므로, 기본값으로 대체하는 것이 좋음
- 대체 키(Surrogate Key) 할당은 필수, 디멘션 멤버별로 유일한 키 필요

### 2-3. 다양한 원천 데이터 통합

- 디멘션 데이터는 여러 원천에서 추출되어 병합 필요
- 고객 정보 등은 부서별, 외부 원천 데이터와 통합
- 표준 식별자 부재 시 퍼지 매칭(철자, 오타, 약어 처리 등) 적용
- 마스터 데이터 관리 시스템(MDM)이 중요한 역할

### 2-4. 운영계 코드 해석 및 룩업

- 운영계 코드에 대한 설명(텍스트)을 룩업 테이블에서 관리
- 룩업 데이터가 없을 경우 기본 설명값 생성 로직 포함
- 비공식 문서(엑셀 등)에서 룩업 데이터 수집할 수 있음

### 2-5. 다대일 및 일대일 관계 검증

- 제품→제품 모델→카테고리 등 계층적 롤업 검증 필요
- 다대일 관계는 “다” 쪽 속성 정렬 및 일치 여부 확인
- 스노우플레이크 모델 적용 시 정규화 및 키 생성 필요
- 스테이징 영역에서 관계 위반 데이터 필터링 권장

### 2-6. 대체 키 할당

- 운영계 키와 대체 키 매핑 테이블 유지
- 대체 키는 일반적으로 증가하는 정수 시퀀스 사용
- 시퀀스 생성 및 키 매핑 SQL 예제 존재

### 2-7. 디멘션 테이블 적재

- 디멘션 테이블이 작더라도 고속 벌크 적재 툴 활용 권장
- 로그 비활성화, 고속 모드, 데이터 파일 정렬 등으로 성능 최적화
- 데이터 변환은 ETL 도구 내에서 미리 처리하는 게 좋음
- 전체 데이터 갱신 시 테이블 일괄 삭제 후 적재 권장

### 2-8. 타입 2 디멘션 이력 관리

- 초기 적재 시 과거 속성 변경 이력 재구성 필요
- 이력 간 시계열이 연속되도록 종료 일자 및 시작 일자 설정
- 분·초 단위 유효 일자 관리 시 정확한 시간 일치 필수
- 스크립트, 절차적 언어로 복잡한 이력 재구성 수행

### 2-9. 정적인 일자 및 기타 디멘션

- 일자 디멘션: 과거부터 현재까지 일별 데이터 채우기 필수
- 다른 소량 디멘션(예: 예산 시나리오 등)도 비슷한 방식 생성
- 현업과 데이터 거버넌스 팀의 승인 필요

---

## 3. Step 6: 팩트 테이블 초기 적재 수행

- 초기 적재 시 대량 데이터 처리(수천 배 큰 규모) 대비
- 운영 중인 테이블이 아니므로 며칠 걸려도 허용됨
- 추출 시 업무에 필요하지 않은 데이터 제외
- 추출 중 통계 및 감사 정보도 함께 축적 권장

---

# 학습 노트: 변경 ETL 프로세스 개발 (Change ETL Process Development)

---

## 개요

- 변경 ETL에서 가장 중요한 작업은 **신규 / 변경 / 삭제 로우 식별**
- 식별 후 데이터 변형 규칙은 초기 적재(Full Load)와 유사하나,
- 특히 디멘션과 일부 팩트 테이블에서는 **업데이트(변경)와 삭제** 처리가 필요함
- 업데이트/삭제는 데이터 웨어하우스에서 비용이 크므로, 성능 최적화가 매우 중요

---

## Step 7: 디멘션 테이블 변경 처리

### 1) 디멘션 데이터 추출 및 스냅샷 생성

- 디멘션 원천 파일 예: 고객 마스터, 제품 마스터 등
- 디멘션과 팩트가 혼합된 원천 데이터도 있음
- 디멘션 테이블 전체 데이터의 현재 스냅샷을 만들어 변경 부분 식별
- 디멘션 테이블이 크면 팩트 변경 처리 기법을 사용하여 변경 로우를 찾음
- 가능한 한 **변경된 열만 추출**하는 것이 효율적 (원천 시스템에서 관리 시 효과적)

### 2) 신규 및 변경 디멘션 로우 식별 방법

- DW/BI팀에서 원천 시스템에 신규/변경/삭제 표시를 의존하지 못할 경우,
- ETL에서 새롭고 변경된 로우를 고비용 비교 연산으로 찾아야 함
- 새로운 디멘션 로우 판별: 원천키 컬럼을 기준으로 기존 디멘션과 비교
- 원천키는 기본키가 아니며, 매핑 안 되는 로우는 신규 삽입 대상
- **타입 2 디멘션**: 새 멤버 등장 시 유효 시작일(예: 어제 날짜)을 설정,
    
    유효 종료일은 시스템이 허용하는 먼 미래 날짜로 설정 (널 값 사용 금지)
    

### 3) 변경된 디멘션 로우 확인 (변경 감지)

- 단순 비교: 기존과 신규 데이터를 컬럼별로 하나씩 비교 → 느림
- 효율적 대안: **해시(Hash) 또는 체크섬(Checksum)** 활용
    - 디멘션 테이블에 해시 타입1, 타입2 컬럼 추가
    - 각 로우의 속성(타입1/타입2)을 해싱하여 저장
    - 신규 데이터도 동일 해싱 후 비교하여 변경 여부 판단
- DB 엔진별로 변경 열을 빠르게 찾는 특수 구문(EXCEPT 등)도 활용 가능

### 4) 삭제 데이터 처리

- 원천 시스템에서 삭제되었다 하더라도 디멘션에서는 삭제하지 않는 경우가 많음
- 연관 팩트 데이터 유지 필요성 때문

### 5) 디멘션 속성 변경 처리 규칙

- ETL 애플리케이션에 **업무 규칙 내재**
- 타입 1 변경: 기존 로우 덮어쓰기 (Overwrite)
- 타입 2 변경: 새 버전 추가 (History 유지)
- 타입 3 변경: 이전 값과 현재 값 칼럼 추가 (구조 변경 필요, 자동화 어려움)

### 6) 디멘션 변경 처리 프로세스 흐름

- 룩업과 키 할당
- 신규/변경 데이터 모두 처리 가능하도록 설계

---

## Step 8: 팩트 테이블 변경 처리

### 1) 변경 처리 배경

- 팩트 테이블은 너무 커서 전체 재적재가 비효율적
- **신규 및 변경 로우만 적재하는 변경 적재(Change Load)** 방식 선호
- 변경 적재는 완전 자동화가 필수

### 2) 팩트 테이블 추출과 품질 체크포인트

- 변경된 팩트 데이터 추출 후 스테이징 영역에 복사본 저장
- 스테이징 데이터 활용 목적:
    - 감사 기록 보관
    - 데이터 품질 검증 출발점
    - 재처리(재작업) 시작점

### 3) 팩트 변형 및 대체 키 파이프라인

- 대체 키 파이프라인은 초기 적재와 유사하나,
- **참조 무결성 오류(외래키 문제)** 자동 처리 필요
- 무결성 오류 처리 방법:
    1. 적재 중단 (실제론 비효율적)
    2. 에러 열 버리기 (업무 필요 없을 때만)
    3. 에러 로우 별도 저장 + 미결 파일 관리
    4. **더미 디멘션 생성 및 매핑 (추천)**
    5. '알 수 없음' 멤버 매핑 (비추천)

### 4) 팩트 테이블의 대체 키 룩업

- 디멘션 테이블의 최근 버전 로우 대상 룩업
- 디멘션의 부분집합으로 제한해 효율화

### 5) 지연 유입 팩트 처리

- 팩트 데이터가 늦게 도착하는 경우 고려
- 타입1 디멘션만 쓰면 문제 없으나,
- 타입2 디멘션 같이 사용 시,
- 유효 시작/종료 일시 조건을 걸어 정확한 디멘션 버전과 연결해야 함

### 6) 변경 팩트 적재 방법

- 초기 적재 때는 고속 적재 기법(빠른 대량 삽입) 사용 가능
- 변경 적재 시 고속 적재가 어려움 (기존 데이터 및 인덱스 존재 등)
- 중소 규모 시스템은 일반 삽입 성능이 충분할 수 있음
- 큰 시스템은 파티션 단위로 변경 적재 (예: 일별 파티션)
- 파티션이 비어있으면 고속 적재 활용 가능하지만,
- 파티션 개수가 너무 많으면 관리가 어려움

---

# 학습 노트: 실시간 구현 (Real-time Implementation)

---

## 1. 실시간 처리의 중요성

- 현대 DW/BI 시스템에서 실시간 데이터 처리 요구가 증가하고 있음
- 현업 사용자는 하루 중에도 최신 데이터 반영을 기대하며, 오래된 데이터는 참기 어려움
- 실시간 시스템 구축은 **업무 요건 정확 이해 + 적합한 ETL 아키텍처 설계 + 여러 기술의 통합**이 필수

---

## 2. 실시간 데이터 분류 및 설계 요건

실시간 요구를 대화할 때, **단순히 "실시간 원하나요?"**라는 질문은 무의미.

실제 실시간은 크게 3가지 옵션으로 구분해서 요건을 구체화해야 함.

| 분류 | 의미 및 특징 | 설계 및 처리 방식 | 사례 및 비고 |
| --- | --- | --- | --- |
| 즉각적(Immediate) | 데이터 변경 즉시 화면 반영원천 시스템 → 사용자 화면 동기적 상태 유지 | EII(Enterprise Information Integration) 솔루션 활용원천 시스템에서 직접 쿼리 응답ETL 캐싱 없음 | 실시간 재고 상태 확인 등쿼리 복잡성 제한 필요 |
| 하루 중(Intra-day) | 데이터가 하루 중 여러 번 갱신됨하지만 절대적 실시간 아님 | 마이크로 배치(micro-batch) 기반 ETL 처리변경 데이터 캡처, 정제, 적재 수행 | 메시지 큐, 트랜잭션 로그, DB 트리거 활용 |
| 매일(Daily) | 화면에 보이는 데이터는 전일 혹은 배치 처리 결과최신 데이터가 아닌 경우도 존재 | 전통적 배치 ETL 방식배치 파일 다운로드 및 신호 대기 후 추출 | 원천 시스템 데이터 보정 완료 후 처리 권장 |

---

## 3. 실시간 아키텍처의 주요 상충관계 및 고려사항

### 3.1 배치 파일 대체 vs. 실시간 데이터 소스

- 배치 파일은 데이터가 정제되고 완성된 상태
- 메시지 큐, 로그 파일 등 실시간 데이터는 미가공 상태
- 업무 규칙이나 보정 로직을 ETL에 다시 구현해야 할 위험 있음

### 3.2 데이터 품질 검사 제한

- 실시간 처리 속도 위해 복잡한 품질 검사는 생략 가능
- 단순 칼럼 단위 검사(포맷, 코드 룩업 등) 정도만 실시
- 구조적, 업무 규칙 검증은 병렬 배치 ETL로 보완해야 함
- 사용자와 ‘실시간 데이터는 임시적이고 완전하지 않을 수 있음’을 사전 합의 필요

### 3.3 팩트와 디멘션 연결 문제

- 실시간 환경에서 팩트 데이터가 디멘션보다 먼저 도착 가능
- 이전 버전 디멘션 사용하거나 더미 디멘션 멤버를 생성하여 연결 처리
- 나중에 정확한 디멘션 데이터가 도착하면 실시간 영역이나 일별 배치 때 갱신

### 3.4 데이터 스테이징 제거

- EII 시스템은 운영 원천 시스템 → 사용자 화면까지 ETL 스테이징 단계 없이 데이터 직접 스트리밍
- 백업, 복원, 규제 준수 등의 책임 범위에 대한 조직적 합의 필요

---

## 4. 프레젠테이션 서버에서의 실시간 파티션 설계

- 실시간 요건을 위해 DW는 과거 시계열 데이터와 현재 상태를 연결해야 함
- **실시간 파티션**: 전통 DW 팩트 테이블과 분리된 별도의 데이터베이스 파티션
- 주요 요구사항:
    - 정적 DW 마지막 갱신 이후 발생 활동 포함
    - 본래 물리적 파티션과 매끄럽게 연결
    - 인덱스 최소화 → 빠른 쿼리 응답
    - 메모리 고정하여 인덱스 없어도 빠른 조회 가능
- 트랜잭션 팩트와 주기적 스냅샷 팩트에 적용 가능 (점진적 스냅샷에는 미적용)

---

## 5. 핵심 요약 및 실무 적용 팁

- 실시간 요구는 업무 중요도와 현실 제약조건에 맞춰 **즉각적 / 하루 중 / 매일** 로 구분
- 즉각적 실시간은 쿼리 복잡성 제한과 데이터 임시성 감수 필요
- 하루 중 실시간은 마이크로 배치와 로그/메시지 큐 활용
- 매일 단위 배치는 안정성과 신뢰성 중심
- 실시간 아키텍처 구축 시 **품질, 규제, 복구, 보안 정책** 유지하면서 상충 관계 조율
- 실시간 데이터 품질 제한 및 디멘션 연결 문제에 대해 사용자와 사전 합의 필수
- 실시간 파티션을 활용해 전통 DW와 실시간 데이터 통합 관리
